<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>ns-3 Change Log</title>
</head>
<body>

<h1>
ns-3: API and model change history</h1>
<!--
This ChangeLog is updated in the reverse order 
with the most recent changes coming first.  Date format:  DD-MM-YYYY
-->
<p>
ns-3 is an evolving system and there will be API or behavioral changes
from time to time.   Users who try to use scripts or models across
versions of ns-3 may encounter problems at compile time, run time, or
may see the simulation output change.  </p>
<p>
We have adopted the development policy that we are going to try to ease
the impact of these changes on users by documenting these changes in a
single place (this file), and not by providing a temporary or permanent
backward-compatibility software layer.  </p>
<p>
A related file is the RELEASE_NOTES file in the top level directory.
This file complements RELEASE_NOTES by focusing on API and behavioral
changes that users upgrading from one release to the next may encounter.
RELEASE_NOTES attempts to comprehensively list all of the changes
that were made.  There is generally some overlap in the information 
contained in RELEASE_NOTES and this file.  </p>
<p>
The goal is that users who encounter a problem when trying to use older
code with newer code should be able to consult this file to find
guidance as to how to fix the problem.  For instance, if a method name
or signature has changed, it should be stated what the new replacement
name is. </p>
<p>
Note that users who upgrade the simulator across versions, or who work
directly out of the development tree, may find that simulation output
changes even when the compilation doesn't break, such as when a
simulator default value is changed.  Therefore, it is good practice for
_anyone_ using code across multiple ns-3 releases to consult this file,
as well as the RELEASE_NOTES, to understand what has changed over time.
</p>
<p>
This file is a best-effort approach to solving this issue; we will do
our best but can guarantee that there will be things that fall through
the cracks, unfortunately.  If you, as a user, can suggest improvements
to this file based on your experience, please contribute a patch or drop
us a note on ns-developers mailing list.</p>

<hr>
<h1>Changes from ns-3.16 to ns-3.17</h1>

<h2>New API:</h2>
<ul>
  <li>New TCP Westwood and Westwood+ models
  <li>New FdNetDevice class providing a special NetDevice that is able to read
      and write traffic from a file descriptor.  Three helpers are provided
      to associate the file descriptor with different underlying devices:  
    <ul> 
    <li> EmuFdNetDeviceHelper (to associate the |ns3| device with a physical 
         device in the host machine).  This helper is intended to
         eventually replace the EmuNetDevice in src/emu. </li>
    <li> TapFdNetDeviceHelper (to associate the ns-3 device with the file 
         descriptor from a tap device in the host machine) </li>
    <li> PlanteLabFdNetDeviceHelper (to automate the creation of tap devices 
         in PlanetLab nodes, enabling |ns3| simulations that can send and 
         receive traffic though the Internet using PlanetLab resource.</li>
    </ul> 
  </li>
  <li>In Ipv4ClickRouting, the following APIs were added:
    <ul>
      <li>Ipv4ClickRouting::SetDefines(), accessible through ClickInternetStackHelper::SetDefines(), for the user to set Click defines from the ns-3 simulation file.</li>
      <li>SIMCLICK_GET_RANDOM_INT click-to-simulator command for ns-3 to drive Click's random number generation.</li>
    </ul>
  </li>  
  <li>LTE module
    <ul>
      <li> New user-visible LTE API
      <ul>
        <li>Two new methods have been added to LteHelper to enable the X2-based handover functionality: AddX2Interface, which setups the X2 interface between two eNBs, and HandoverRequest, which is  a convenience method that schedules an explicit handover event to be executed at a given point in the simulation. </li>
        <li>the new LteHelper method EnablePhyTraces can now be used to enable the new PHY traces</li>
      </ul>
      </li> 
      <li> New internal LTE API 
      <ul>
        <li>New LTE control message classes DlHarqFeedbackLteControlMessage, 
         RachPreambleLteControlMessage, RarLteControlMessage, MibLteControlMessage</li>
        <li>New class UeManager
        <li>New LteRadioBearerInfo subclasses LteSignalingRadioBearerInfo, 
         LteDataRadioBearerInfo</li>
        <li>New LteSinrChunkProcessor subclasses LteRsReceivedPowerChunkProcessor, 
         LteInterferencePowerChunkProcessor</li>
      </ul>
      </li>
    </ul>
  </li>
  <li>New DSR API
  <ul>
    <li>Added PassiveBuffer class to save maintenance packet entry for passive acknowledgment option</li>
    <li>Added FindSourceEntry function in RreqTable class to keep track of route request entry received from same source node</li>
    <li>Added NotifyDataReciept function in DsrRouting class to notify the data receipt of the next hop from link layer.  This is used for the link layer acknowledgment.</li>
  </ul>
  </li>
  <li>New Tag, PacketSocketTag, to carry the destination address of a packet and the packet type</li>
  <li>New Tag, DeviceNameTag, to carry the ns3 device name from where a packet is coming</li>
  <li>New Error Model, BurstError model, to determine which bursts of packets are errored corresponding to an underlying distribution, burst rate, and burst size</li>
</ul>

<h2>Changes to existing API:</h2>
<ul>
  <li>ns3::Object and subclasses DoStart has been renamed to DoInitialize</li>
  <li>ns3::Object and subclasses Start has been renamed to Initialize</li>
  <li>EnergySource StartDeviceModels renamed to InitializeDeviceModels</li>
  <li>A typo was fixed in an LTE variable name. The variable ns3::AllocationRetentionPriority::preemprionVulnerability was changed to preemptionVulnerability.</li>
  <li>Changes in TestCase API
  <ul>
    <li>TestCase has new enumeration TestDuration containing QUICK, EXTENSIVE, TAKES_FOREVER</li>
    <li>TestCase constructor now requires TestDuration, old constructor marked deprecated</li>
 </ul>
 </li>
  <li>Changes in LTE API
  <ul>
    <li> User-visible LTE API 
    <ul>
      <li>The previous LteHelper method ActivateEpsBearer has been now replaced by two alternative methods: ActivateDataRadioBearer (to be used when the EPC model is not used) and ActivateDedicatedEpsBearer (to be used when the EPC model is used). In the case where the EPC model is used, the default EPS bearer is not automatically activated without the need for a specific method to be called.</li>
    </ul>
    </li> 
    <li> Internal LTE API 
    <ul>
      <li>EpcHelper added methods AddUe, AddX2Interface.  Method AddEnb now requires a cellId.  Signature of ActivateEpsBearer changed to void ActivateEpsBearer (Ptr<NetDevice> ueLteDevice, uint64_t imsi, Ptr<EpcTft> tft, EpsBearer bearer)</li>
      <li>LteHelper added methods EnableDlPhyTraces, EnableUlPhyTraces, EnableDlTxPhyTraces, EnableUlTxPhyTraces, EnableDlRxPhyTraces, EnableUlRxPhyTraces</li>
      <li>LteHelper removed methods EnableDlRlcTraces, EnableUlRlcTraces, EnableDlPdcpTraces, EnableUlPdcpTraces</li>
      <li>RadioBearerStatsCalculator added methods (Set/Get)StartTime, (Set/Get)Epoch, RescheduleEndEpoch, EndEpoch</li>
      <li>RadioBearerStatsCalculator removed methods StartEpoch, CheckEpoch</li>
      <li>RadioBearerStatsCalculator methods UlTxPdu, DlRxPdu now require a cellId</li>
      <li>EpcEnbApplication constructor now requires Ipv4Addresses enbS1uAddress and sgwS1uAddress as well as cellId</li>
      <li>EpcEnbApplication added methods SetS1SapUser, GetS1SapProvider, SetS1apSapMme and GetS1apSapEnb</li>
      <li>EpcEnbApplication removed method ErabSetupRequest</li> 
      <li>EpcSgwPgwApplication added methods SetS11SapMme, GetS11SapSgw, AddEnb, AddUe, SetUeAddress</li>
      <li>lte-common.h new structs PhyTransmissionStatParameters and PhyReceptionStatParameters used in TracedCallbacks</li>
      <li>LteControlMessage new message types DL_HARQ, RACH_PREAMBLE, RAR, MIB</li>
      <li>LteEnbCmacSapProvider new methods RemoveUe, GetRachConfig, AllocateNcRaPreamble, AllocateTemporaryCellRnti</li>
      <li>LteEnbPhy new methods GetLteEnbCphySapProvider, SetLteEnbCphySapUser, GetDlSpectrumPhy, GetUlSpectrumPhy, CreateSrsReport</li>
      <li>LteEnbPhy methods DoSendMacPdu, DoSetTransmissionMode, DoSetSrsConfigurationIndex, DoGetMacChTtiDelay, DoSendLteControlMessage, AddUePhy, DeleteUePhy made private</li>
      <li>LteEnbPhySapProvider removed methods SetBandwidth, SetTransmissionMode, SetSrsConfigurationIndex, SetCellId</li>
      <li>LteEnbPhySapUser added methods ReceiveRachPreamble, UlInfoListElementHarqFeeback, DlInfoListElementHarqFeeback</li>
      <li>LtePdcp added methods (Set/Get)Status</li>
      <li>LtePdcp DoTransmitRrcPdu renamed DoTransmitPdcpSdu</li>
      <li>LteUeRrc new enum State.  New methods SetLteUeCphySapProvider, GetLteUeCphySapUser, SetLteUeRrcSapUser, GetLteUeRrcSapProvider, GetState, GetDlEarfcn, GetDlBandwidth, GetUlBandwidth, GetCellId, SetUseRlcSm .  GetRnti made const.</li> 
      <li>LteUeRrc removed methods ReleaseRadioBearer, GetLcIdVector, SetForwardUpCallback, DoRrcConfigurationUpdateInd</li>
      <li>LtePdcpSapProvider struct TransmitRrcPduParameters renamed TransmitPdcpSduParameters.  Method TransmitRrcPdu renamed TransmitPdcpSdu </li>
      <li>LtePdcpSapUser struct ReceiveRrcPduParameters renamed ReceivePdcpSduParameters.  Method ReceiveRrcPdu renamed TransmitPdcpSdu</li>
      <li>LtePdcpSpecificLtePdcpSapProvider method TransmitRrcPdu renamed TransmitPdcpSdu</li>
      <li>LtePdcpSpecificLtePdcpSapUser method ReceiveRrcPdu  renamed ReceivePdcpSdu. Method ReceiveRrcPdu renamed ReceivePdcpSdu</li>
      <li>LtePhy removed methods DoSetBandwidth and DoSetEarfcn</li>
      <li>LtePhy added methods ReportInterference and ReportRsReceivedPower</li>
      <li>LteSpectrumPhy added methods SetHarqPhyModule, Reset, SetLtePhyDlHarqFeedbackCallback, SetLtePhyUlHarqFeedbackCallback,  AddRsPowerChunkProcessor, AddInterferenceChunkProcessor</li>
      <li>LteUeCphySapProvider removed methods ConfigureRach, StartContentionBasedRandomAccessProcedure, StartNonContentionBasedRandomAccessProcedure</li>
      <li>LteUeMac added method AssignStreams</li>
      <li>LteUeNetDevice methods GetMac, GetRrc, GetImsi  made const</li>
      <li>LteUeNetDevice new method GetNas</li>
      <li>LteUePhy new methods GetLteUeCphySapProvider, SetLteUeCphySapUser, GetDlSpectrumPhy, GetUlSpectrumPhy, ReportInterference, ReportRsReceivedPower, ReceiveLteDlHarqFeedback</li>
      <li>LteUePhy DoSendMacPdu, DoSendLteControlMessage, DoSetTransmissionMode, DoSetSrsConfigurationIndex made private</li>
      <li>LteUePhySapProvider removed methods SetBandwidth, SetTransmissionMode, SetSrsConfigurationIndex</li>
      <li>LteUePhySapProvider added method SendRachPreamble</li>  
    </ul>
   </li>    
  </ul>
  <li>AnimationInterface method EnableIpv4RouteTracking returns reference to calling AnimationInterface object</li>
  <li>To make the API more uniform across the various
  PropagationLossModel classes, the Set/GetLambda methods of the
  FriisPropagationLossModel and TwoRayGroundPropagationLossModel
  classes have been changed to Set/GetFrequency, and now a Frequency
  attribute is exported which replaces the pre-existing Lambda
  attribute. Any previous user code setting a value for Lambda should
  be changed to set instead a value of Frequency = C / Lambda, with C
  = 299792458.0. </li>
</ul>
<h2>Changes to build system:</h2>
<ul>
  <li>Waf shipped with ns-3 has been upgraded to version 1.7.10 and custom
  pkg-config generator has been replaced by Waf's builtin tool.
  </li>
</ul>

<h2>Changed behavior:</h2>
<ul>
  <li>DSR link layer notification has changed.  The model originally used 
  "TxErrHeader" in Ptr<WifiMac> to indicate the transmission
  error of a specific packet in link layer; however, it was not working
  correctly.  The model now uses a different path to implement
  the link layer notification mechanism; specifically, looking into the 
  trace file to find packet receive events.  If the model finds one 
  receive event for the data packet, it is used as the indicator for 
  successful data delivery.</li>
</ul>

<hr>
<h1>Changes from ns-3.15 to ns-3.16</h1>

<h2>New API:</h2>
<ul>
<li>In the Socket class, the following functions were added: 
 <ul>
  <li>(Set/Get)IpTos - sets IP Type of Service field in the IP headers.</li>
  <li>(Set/Is)IpRecvTos - tells the socket to pass information about IP ToS up the stack (by adding SocketIpTosTag to the packet).</li>
  <li>(Set/Get)IpTtl - sets IP Time to live field in the IP headers.</li>
  <li>(Set/Is)RecvIpTtl - tells the socket to pass information about IP TTL up the stack (by adding SocketIpTtlTag to the packet).</li>
  <li>(Set/Is)Ipv6Tclass - sets Traffic Class field in the IPv6 headers.</li>
  <li>(Set/Is)Ipv6RecvTclass - tells the socket to pass information about IPv6 TCLASS up the stack (by adding SocketIpv6TclassTag to the packet).</li>
  <li>(Set/Get)Ipv6HopLimit - sets Hop Limit field in the IPv6 headers.</li>
  <li>(Set/Is)Ipv6RecvHopLimit - tells the socket to pass information about IPv6 HOPLIMIT up the stack (by adding SocketIpv6HoplimitTag to the packet).</li>
 </ul>  
A user can call these functions to set/get the corresponding socket option. See examples/socket/socket-options-ipv4.cc and examples/socket/socket-options-ipv6.cc for examples.
</ul>

<h2>Changes to existing API:</h2>
<ul>
<li>In the MobilityHelper class, the functions EnableAscii () and EnableAsciiAll () were changed to use output stream wrappers rather than standard C++ ostreams. The purpose of this change was to make them behave analogously to other helpers in ns-3 that generate ascii traces.  Now, the file stream that is open in MobilityHelper is closed nicely upon asserts and program exits.</li>
</ul>

<h2>Changes to build system:</h2>
<ul>
<li>It's now possible to use distcc when building ns-3. See tutorial for details.</li>
</ul>

<h2>Changed behavior:</h2>
<ul>
<li>Sending a packet through Ipv4RawSocket now supports checksum in the Ipv4Header. It is still not possible to manually put in arbitrary checksum as the checksum is automatically calculated at Ipv4L3Protocol. The user has to enable checksum globally for this to work. Simply calling Ipv4Header::EnableChecksum() for a single Ipv4Header will not work.</li>
<li>Now MultiModelSpectrumChannel allows a SpectrumPhy instance to change SpectrumModel at runtime by issuing a call to MultiModelSpectrumChannel::AddRx (). Previously, MultiModelSpectrumChannel required each SpectrumPhy instance to stick with the same SpectrumModel for the whole simulation. 
</li>
</ul>

<hr>
<h1>Changes from ns-3.14 to ns-3.15</h1>

<h2>New API:</h2>
<ul>
<li>A RandomVariableStreamHelper has been introduced to assist with 
using the Config subsystem path names to assign fixed stream numbers
to RandomVariableStream objects.</li>
</ul>

<h2>Changes to existing API:</h2>
<ul>
<li>Derived classes of RandomVariable (i.e. the random variable 
implementations) have been ported to a new RandomVariableStream base class.
<li>For a given distribution DistributionVariable (such as UniformVariable),
the new class name is DistributionRandomVariable (such as 
UniformRandomVariable). </li>
<li>The new implementations are also derived from class ns3::Object and 
are handled using the ns-3 smart pointer (Ptr) class.  </li>
<li>The new variable classes also have a new attributed called "Stream"
which allows them to be assigned to a fix stream index when assigned
to the underlying pseudo-random stream of numbers.</li>
</li>
</ul>

<h2>Changes to build system:</h2>
<ul>
<li></li>
</ul>

<h2>Changed behavior:</h2>
<ul>
<li>Programs using random variables or models that include random variables 
may exhibit changed output for a given run number or seed, due to a possible 
change in the order in which random variables are assigned to underlying 
pseudo-random sequences.  Consult the manual for more information regarding 
this.</li>
</ul>

<hr>
<h1>Changes from ns-3.13 to ns-3.14</h1>

<h2>New API:</h2>
<ul>
<li>The new class AntennaModel provides an API for modeling the radiation pattern of antennas.
</li>
<li>The new buildings module introduces an API (classes, helpers, etc)
  to model the presence of buildings in a wireless network topology. 
</li>
<li>The LENA project's implementation of the LTE Mac Scheduler Interface Specification
   standardized by the Small Cell Forum (formerly Femto Forum) is now available for
  use with the LTE module.
</li>
</ul>

<h2>Changes to existing API:</h2>
<ul>
<li> The Ipv6RawSocketImpl "IcmpFilter" attribute has been removed. Six 
new member functions have been added to enable the same functionality.
</li>
<li> IPv6 support for TCP and UDP has been implemented.  Socket functions
that take an address [e.g. Send (), Connect (), Bind ()] can accept an
ns3::Ipv6Address or a ns3::Address in addition to taking an ns3::Ipv4Address.
(Note that the ns3::Address must contain a ns3::Ipv6Address or a ns3::Ipv4Address,
otherwise these functions will return an error).
Internally, the socket now stores the remote address as a type "ns3::Address"
instead of a type "ns3::Ipv4Address".  The IPv6 Routing Header extension is not
currently supported in ns3 and will not be reflected in the TCP and UDP checksum
calculations per RFC 2460.  Also note that UDP checksums for IPv6 packets are
required per RFC, but remain optional and disabled by default in ns3 (in the
interest of performance).
</li>
<li>
When calling Bind () on a socket without an address, the behavior remains the
same: it will bind to the IPv4 "any" address (0.0.0.0).  In order to Bind () to
the IPv6 "any" address in a similar fashion, use "Bind6 ()".
</li>
<li>
The prototype for the RxCallback function in the Ipv6EndPoint was changed.
It now includes the destination IPv6 address of the end point which was
needed for TCP.  This lead to a small change in the UDP and ICMPv6 L4
protocols as well.
</li>
<li>
Ipv6RoutingHelper can now print the IPv6 Routing Tables at specific 
intervals or time. Exactly like Ipv4RoutingHelper do.
</li>
<li>
New "SendIcmpv6Redirect" attribute (and getter/setter functions) to 
Ipv6L3Protocol. The behavior is similar to Linux's conf "send_redirects", 
i.e., enable/disable the ICMPv6 Redirect sending.
</li>
<li> The SpectrumPhy abstract class now has a new method
<pre>virtual Ptr&#60;AntennaModel&#62; GetRxAntenna () = 0;</pre>
that all derived classes need to implement in order to integrate properly with the newly added antenna model. In addition, a new member variable "Ptr&#60;AntennaModel&#62; txAntenna" has been added to SpectrumSignalParameters in order to allow derived SpectrumPhy classes to provide information about the antenna model used for the transmission of a waveform.
</li>
<li> The Ns2CalendarScheduler event scheduler has been removed.
</li>
<li>
ErrorUnit enum has been moved into RateErrorModel class, and symbols EU_BIT, EU_BYTE and EU_PKT have been renamed to RateErrorModel::ERROR_UNIT_BIT, RateErrorModel::ERROR_UNIT_BYTE and RateErrorModel::ERROR_UNIT_PACKET. RateErrorModel class attribute "ErrorUnit" values have also been renamed for consistency, and are now "ERROR_UNIT_BIT", "ERROR_UNIT_BYTE", "ERROR_UNIT_PACKET".
</li>
<li>
QueueMode enum from DropTailQueue and RedQueue classes has been unified and moved to Queueu class. Symbols DropTailQueue::PACKETS and DropTailQueue::BYTES are now named Queue::QUEUE_MODE_PACKETS and DropTailQueue::QUEUE_MODE_BYTES. In addition, DropTailQueue and RedQueue class attributes "Mode" have been renamed for consistency from "Packets" and "Bytes" to "QUEUE_MODE_PACKETS" and "QUEUE_MODE_BYTES".
</li>
<li>
The API of the LTE module has undergone a significant redesign with
the merge of the code from the LENA project. The new API is not
backwards compatible with the previous version of the LTE module.
</li>
<li> The Ipv6AddressHelper API has been aligned with the Ipv4AddressHelper API. 
The helper can be set with a call to Ipv6AddressHelper::SetBase 
(Ipv6Address network, Ipv6Prefix prefix) instead of NewNetwork
(Ipv6Address network, Ipv6Prefix prefix).  A new NewAddress (void) method
has been added.  Typical usage will involve calls to SetBase (), NewNetwork (),
and NewAddress (), as in class Ipv4AddressHelper. 
</li>
</ul>

<h2>Changes to build system:</h2>
<ul>
<li> The following files are removed:
<pre>
  src/internet/model/ipv4-l4-protocol.cc
  src/internet/model/ipv4-l4-protocol.h
  src/internet/model/ipv6-l4-protocol.cc
  src/internet/model/ipv6-l4-protocol.h
</pre>
and replaced with:
<pre>
  src/internet/model/ip-l4-protocol.cc
  src/internet/model/ip-l4-protocol.h
</pre>
</li>
</ul>
<h2>Changed behavior:</h2>
<ul>
<li> Dual-stacked IPv6 sockets are implemented.  An IPv6 socket can accept
an IPv4 connection, returning the senders address as an IPv4-mapped address
(IPV6_V6ONLY socket option is not implemented).
</li>
<li>
The following examples/application/helpers were modified to support IPv6:
<pre>
csma-layout/examples/csma-star [*]
netanim/examples/star-animation [*]
point-to-point-layout/model/point-to-point-star.cc
point-to-point-layout/model/point-to-point-grid.cc
point-to-point-layout/model/point-to-point-dumbbell.cc
examples/udp/udp-echo [*]
examples/udp-client-server/udp-client-server [*]
examples/udp-client-server/udp-trace-client-server [*]
applications/helper/udp-echo-helper
applications/model/udp-client
applications/model/udp-echo-client
applications/model/udp-echo-server
applications/model/udp-server
applications/model/udp-trace-client

[*]  Added '--useIpv6' flag to switch between IPv4 and IPv6
</pre>
</li>
</ul>

<hr>
<h1>Changes from ns-3.12 to ns-3.13</h1>

<h2>Changes to build system:</h2>
<ul>
<li> The underlying version of waf used by ns-3 was upgraded to 1.6.7.  
This has a few changes for users and developers:
<ul>
<li> by default, "build" no longer has a subdirectory debug or optimized.  
To get different build directories for different build types, you can use 
the waf configure -o <argument> option, e.g.:
<pre>
  ./waf configure -o shared
  ./waf configure --enable-static -o static
</pre>
</li>
<li> (for developers) the ns3headers taskgen needs to be created with a 
features parameter name:
<pre>
  -  headers = bld.new_task_gen('ns3header')
  +  headers = bld.new_task_gen(features=['ns3header'])
</pre>
<li> no longer need to edit src/wscript to add a module, just create your 
module directory inside src and ns-3 will pick it up
<li> In WAF 1.6, adding -Dxxx options is done via the DEFINES env. var.
instead of CXXDEFINES
<li> waf env values are always lists now, e.g. env['PYTHON'] returns
['/usr/bin/python'], so you may need to add [0] to the value in some places
</ul> 
</ul>

<h2>New API:</h2>
<ul>
<li> In the mobility module, there is a new MobilityModel::GetRelativeSpeed() method returning the relative speed of two objects. </li>
<li> A new Ipv6AddressGenerator class was added to generate sequential
addresses from a provided base prefix and interfaceId.  It also will detect
duplicate address assigments. </li> 
</ul>

<h2>Changes to existing API:</h2>
<ul>
<li> In the spectrum module, the parameters to SpectrumChannel::StartTx () and SpectrumPhy::StartRx () methods are now passed using the new struct SpectrumSignalParameters. This new struct supports inheritance, hence it allows technology-specific PHY implementations to provide technology-specific parameters in SpectrumChannel::StartTx() and SpectrumPhy::StartRx(), while at the same time keeping a set of technology-independent parameters common across all spectrum-enabled PHY implementations (i.e., the duration and the power spectral density which are needed for interference calculation). Additionally, the SpectrumType class has been removed, since now the type of a spectrum signal can be inferred by doing a dynamic cast on SpectrumSignalParameters. See the <A href="http://mailman.isi.edu/pipermail/ns-developers/2011-October/009495.html" >Spectrum API change discussion on ns-developers</A> for the motivation behind this API change.
</li>

<li> The WifiPhyStandard enumerators for specifying half- and quarter-channel 
width standards has had a change in capitalization:
<ul>
<li> WIFI_PHY_STANDARD_80211_10Mhz was changed to WIFI_PHY_STANDARD_80211_10MHZ
<li> WIFI_PHY_STANDARD_80211_5Mhz was changed to WIFI_PHY_STANDARD_80211_5MHZ
</ul>
<li> In the SpectrumPhy base class, the methods to get/set the
  MobilityModel and the NetDevice were previously working with
  opaque Ptr&#60;Object&#62;. Now all these methods have been
  changed so that they work with Ptr&#60;NetDevice&#62;
  and Ptr&#60;MobilityModel&#62; as appropriate. See <A href="https://www.nsnam.org/bugzilla/show_bug.cgi?id=1271">Bug 1271</A> on
  bugzilla for the motivation.
</li>
</ul>

<h2>Changed behavior:</h2>
<ul>
<li> TCP bug fixes
<ul> 
<li> Connection retries count is a separate variable with the retries limit, so cloned sockets can reset the count
<li> Fix bug on RTO that may halt the data flow
<li> Make TCP endpoints always holds the accurate address:port info
<li> RST packet is sent on closed sockets
<li> Fix congestion window sizing problem upon partial ACK in TcpNewReno
<li> Acknowledgement is sent, rather than staying silent, upon arrival of unacceptable packets
<li> Advance TcpSocketBase::m_nextTxSequence after RTO
</ul>
<li> TCP enhancements
<ul>
<li> Latest RTT value now stored in variable TcpSocketBase::m_lastRtt
<li> The list variable TcpL4Protocol::m_sockets now always holds all the created, running TcpSocketBase objects
<li> Maximum announced window size now an attribute, ns3::TcpSocketBase::MaxWindowSize
<li> TcpHeader now recognizes ECE and CWR flags (c.f. RFC3168)
<li> Added TCP option handling call in TcpSocketBase for future extension
<li> Data out of range (i.e. outsize acceptable range of receive window) now computed on bytes, not packets
<li> TCP moves from time-wait state to closed state after twice the time specified by attribute ns3:TcpSocketBase::MaxSegLifeTime
<li> TcpNewReno supports limited transmit (RFC3042) if asserting boolean attribute ns3::TcpNewReno::LimitedTransmit
<li> Nagle's algorithm supported. Default off, turn on by calling TcpSocket::SetTcpNoDelay(true)
</ul>
</ul>

<hr>
<h1>Changes from ns-3.11 to ns-3.12</h1>

<h2>Changes to build system:</h2>
<ul>
</ul>

<h2>New API:</h2>
<ul>
<li> New method, RegularWifiMac::SetPromisc (void), to set the interface
to promiscuous mode.
</ul>

<h2>Changes to existing API:</h2>
<ul>
<li> The spelling of the attribute 'IntialCellVoltage' from LiIonEnergySource 
was corrected to 'InitialCellVoltage'; this will affect existing users who 
were using the attribute with the misspelling.
<li> Two trace sources in class WifiPhy have had their names changed:
<ul> 
<li> 'PromiscSnifferRx' is now 'MonitorSnifferRx'
<li> 'PromiscSnifferTx' is now 'MonitorSnifferTx'
</ul>
</ul>

<h2>Changed behavior:</h2>
<ul>
<li> IPv4 fragmentation is now supported.
</ul>

<hr>
<h1>Changes from ns-3.10 to ns-3.11</h1>

<h2>Changes to build system:</h2>
<ul>
<li><b>Examples and tests are no longer built by default in ns-3</b>
<p>
You can now make examples and tests be built in ns-3 in two ways.
<ol>
<li> Using build.py when ns-3 is built for the first time:
<pre>
    ./build.py --enable-examples --enable-tests
</pre>
<li> Using waf once ns-3 has been built:
<pre>
    ./waf configure --enable-examples --enable-tests
</pre>
</ol>
</p></li>
<li><b> Subsets of modules can be enabled using the ns-3 configuration file</b>
<p>A new configuration file, .ns3rc, has been added to ns-3 that
specifies the modules that should be enabled during the ns-3 build.
See the documentation for details.
</p></li>
</ul>

<h2>New API:</h2>
<ul>
<li><b>int64x64_t</b>
<p>The <b>int64x64_t</b> type implements all the C++ arithmetic operators to behave like one of the
C++ native types. It is a 64.64 integer type which means that it is a 128bit integer type with
64 bits of fractional precision. The existing <b>Time</b> type is now automatically convertible to
<b>int64x64_t</b> to allow arbitrarily complex arithmetic operations on the content of <b>Time</b>
objects. The implementation of <b>int64x64_t</b> is based on the previously-existing
<b>HighPrecision</b> type and supercedes it.
</p></li>
</ul>

<h2>Changes to existing API:</h2>
<ul>
<li><b>Wifi TX duration calculation moved from InterferenceHelper to WifiPhy</b>
<p>The following static methods have been moved from the InterferenceHelper class to the WifiPhy class:
   <pre>
static Time CalculateTxDuration (uint32_t size, WifiMode payloadMode, enum WifiPreamble preamble);
static WifiMode GetPlcpHeaderMode (WifiMode payloadMode, WifiPreamble preamble);
static uint32_t GetPlcpHeaderDurationMicroSeconds (WifiMode payloadMode, WifiPreamble preamble);
static uint32_t GetPlcpPreambleDurationMicroSeconds (WifiMode payloadMode, WifiPreamble preamble);
static uint32_t GetPayloadDurationMicroSeconds (uint32_t size, WifiMode payloadMode);
</pre>
</p></li>
<li><b>Test cases no longer return a boolean value</b>
<p>Unit test case DoRun() functions no longer return a bool value.  Now, they don't return a value at all.  The motivation for this change was to disallow users from merely returning "true" from a test case to force an error to be recorded.  Instead, test case macros should be used.
</p></li>
<li><b>PhyMac renamed to GenericPhy</b>
<p>The PhyMac interface previously defined in phy-mac.h has been
  renamed to GenericPhy interface and moved to a new file
  generic-phy.h. The related variables and methods have been renamed accordingly. 
</p></li>
<li><b>Scalar</b>
<p>The Scalar type has been removed. Typical code such as:
<pre>
Time tmp = ...;
Time result = tmp * Scalar (5);
</pre>
Can now be rewritten as:
<pre>
Time tmp = ...;
Time result = Time (tmp * 5);
</pre>
</p>
</li>
<li><b>Multicast GetOutputTtl() commands</b>
<p> As part of bug 1047 rework to enable multicast routes on nodes with
more than 16 interfaces, the methods Ipv4MulticastRoute::GetOutputTtl () 
and Ipv6MulticastRoute::GetOutputTtl () have been modified to return
a std::map of interface IDs and TTLs for the route.
</p>
</li>
</ul>

<h2>Changed behavior:</h2>
<ul>
</ul>

<hr>
<h1>Changes from ns-3.9 to ns-3.10</h1>

<h2>Changes to build system:</h2>
<ul>
<li><b>Regression tests are no longer run using waf</b>
<p>All regression testing is now being done in test.py.  As a result, a 
separate reference trace repository is no longer needed to perform 
regression tests.  Tests that require comparison against known good traces
can still be run from test.py.  The --regression option for waf has been
removed.  However, the "-r" option to download.py has been kept to 
allow users to fetch older revisions of ns-3 that contain these traces.
</p>
<li><b>Documentation converted to Sphinx</b>
<p> Project documentation (manual, tutorial, and testing) have been
converted to Sphinx from the GNU Texinfo markup format.</p>
</ul>

<h2>New API:</h2>
<ul>
<li><b>Pyviz visualizer</b>  
<p>A Python-based visualizer called pyviz is now integrated with ns-3.
For Python simulations, there is an API to start the visualizer.  You
have to import the visualizer module, and call visualizer.start()
instead of ns3.Simulator.Run().  For C++ simulations, there is no API.
For C++ simulations (but also works for Python ones) you need to set
the GlobalValue SimulatorImplementationType to
"ns3::VisualSimulatorImpl".  This can be set from the command-line,
for example (add the
<tt>--SimulatorImplementationType=ns3::VisualSimulatorImpl</tt>
option), or via the waf option <tt>--visualizer</tt>, in addition to
the usual <tt>--run</tt> option to run programs.
</p></li>

<li><b>WaypointMobility attributes</b>
<p>Two attributes were added to WaypointMobility model:  LazyNotify and
InitialPositionIs Waypoint.  See RELEASE_NOTES for details.  </p> </li>

<li><b>802.11g rates for ERP-OFDM added</b>
<p>New WifiModes of the form ErpOfdmRatexxMbps, where xx is the rate
in Mbps (6, 9, 12, 18, 24, 36, 48, 54), are available for 802.11g.  
More details are in the RELEASE_NOTES.  </p> </li>

<li><b>Socket::GetSocketType ()</b>
<p>This is analogous to getsockopt(SO_TYPE). ipv4-raw-socket, ipv6-raw-socket,
  and packet-socket return NS3_SOCK_RAW. tcp-socket and nsc-tcp-socket return
  NS3_SOCK_STREAM. udp-socket returns NS3_SOCK_DGRAM.</p></li>

<li><b>BulkSendApplication</b>
<p>Sends data as fast as possible up to MaxBytes or unlimited if MaxBytes is 
zero.  Think OnOff, but without the "off" and without the variable data rate. 
This application only works with NS3_SOCK_STREAM and NS3_SOCK_SEQPACKET sockets, 
for example TCP sockets and not UDP sockets. A helper class exists to 
facilitate creating BulkSendApplications. The API for the helper class 
is similar to existing application helper classes, for example, OnOff.
</p></li>

<li><b>Rakhmatov Vrudhula non-linear battery model</b>
<p>New class and helper for this battery model. </p></li>

<li><b>Print IPv4 routing tables</b>
<p>New class methods and helpers for printing IPv4 routing tables
to an output stream. </p></li>

<li><b>Destination-Sequenced Distance Vector (DSDV) routing protocol</b>
<p>Derives from Ipv4RoutingProtocol and contains a DsdvHelper class. </p></li>

<li><b>3GPP Long Term Evolution (LTE) models</b>
<p>More details are in the RELEASE_NOTES. </p></li>

</ul>

<h2>Changes to existing API:</h2>
<ul>
<li><b>Consolidation of Wi-Fi MAC high functionality</b>
<p>Wi-Fi MAC high classes have been reorganised in attempt to
consolidate shared functionality into a single class. This new class
is RegularWifiMac, and it derives from the abstract WifiMac, and is
parent of AdhocWifiMac, StaWifiMac, ApWifiMac, and
MeshWifiInterfaceMac. The QoS and non-QoS class variants are no
longer, with a RegularWifiMac attribute "QosSupported" allowing
selection between these two modes of operation. QosWifiMacHelper and
NqosWifiMacHelper continue to work as previously, with a
behind-the-scenes manipulation of the 'afore-mentioned attribute.
</p></li>

<li><b>New TCP architecture</b>
<p>TcpSocketImpl was replaced by a new base class TcpSocketBase and
several subclasses implementing different congestion control.  From 
a user-level API perspective, the main change is that a new attribute
"SocketType" is available in TcpL4Protocol, to which a TypeIdValue
of a specific Tcp variant can be passed.  In the same class, the attribute 
"RttEstimatorFactory" was also renamed "RttEstimatorType" since it now
takes a TypeIdValue instead of an ObjectFactoryValue.  In most cases, 
however, no change to existing user programs should be needed.
</p></li>
</ul>

<h2>Changed behavior:</h2>
<ul>
<li><b>EmuNetDevice uses DIX instead of LLC encapsulation by default</b>
<p>bug 984 in ns-3 tracker:  real devices don't usually understand LLC/SNAP
so the default of DIX makes more sense.
</p></li>
<li><b>TCP defaults to NewReno congestion control</b>
<p>As part of the TCP socket refactoring, a new TCP implementation provides
slightly different behavior than the previous TcpSocketImpl that provided
only fast retransmit.  The default behavior now is NewReno which provides
fast retransmit and fast recovery with window inflation during recovery.
</p></li>
</ul>

<hr>
<h1>Changes from ns-3.8 to ns-3.9</h1>

<h2>Changes to build system:</h2>

<h2>New API:</h2>
<ul>
<li><b>Wifi set block ack threshold:</b> Two methods for setting block ack
parameters for a specific access class: 
<pre>
void QosWifiMacHelper::SetBlockAckThresholdForAc (enum AccessClass accessClass, uint8_t threshold);
void QosWifiMacHelper::SetBlockAckInactivityTimeoutForAc (enum AccessClass accessClass, uint16_t timeout);
</pre>
</li>
<li><b>Receive List Error Model:</b>  Another basic error model that allows
the user to specify a list of received packets that should be errored.  The
list corresponds not to the packet UID but to the sequence of received
packets as observed by the error model.   See src/common/error-model.h
</li>
<li><b>Respond to interface events:</b> New attribute for Ipv4GlobalRouting,
"RespondToInterfaceEvents", which when enabled, will cause global routes
to be recomputed upon any interface or address notification event from IPv4.
</li>
<li><b>Generic sequence number:</b> New generic sequence number class to 
easily handle comparison, subtraction, etc. for sequence numbers.  
To use it you need to supply two fundamental types as template parameters: 
NUMERIC_TYPE and SIGNED_TYPE.  For instance, <tt>SequenceNumber&lt;uint32_t, int32_t&gt;</tt> 
gives you a 32-bit sequence number, while <tt>SequenceNumber&lt;uint16_t, int16_t&gt;</tt> 
is a 16-bit one.  For your convenience, these are typedef'ed as 
<tt>SequenceNumber32</tt> and <tt>SequenceNumber16</tt>, respectively.
</li>

<li><b>Broadcast socket option:</b> New Socket
methods <tt>SetAllowBroadcast</tt> and <tt>GetAllowBroadcast</tt> add
to NS-3 <tt>Socket</tt>'s the equivalent to the POSIX SO_BROADCAST
socket option (setsockopt/getsockopt).  Starting from this NS-3
version, IPv4 sockets do not allow us to send packets to broadcast
destinations by default; SetAllowBroadcast must be called beforehand
if we wish to send broadcast packets.
</li>

<li><b>Deliver of packet ancillary information to sockets:</b> A method to deliver ancillary information 
to the socket interface (fixed in bug 671):  <pre>void Socket::SetRecvPktInfo (bool flag);</pre>

</ul>

<h2>Changes to existing API:</h2>

<ul>
<li><b>Changes to construction and naming of Wi-Fi transmit rates:</b>
A reorganisation of the construction of Wi-Fi transmit rates has been
undertaken with the aim of simplifying the task of supporting further
IEEE 802.11 PHYs. This work has been completed under the auspices of
Bug 871.

From the viewpoint of simulation scripts not part of the ns-3
distribution, the key change is that WifiMode names of the form
wifi<em>x</em>-<em>n</em>mbs are now invalid. Names now take the
form <em>Cccc</em>Rate<em>n</em>Mbps[BW<em>b</em>MHz],
where <em>n</em> is the root bitrate in megabits-per-second as before
(with only significant figures included, and an underscore replacing
any decimal point), and <em>Cccc</em> is a representation of the
Modulation Class as defined in Table 9-2 of IEEE
Std. 802.11-2007. Currently-supported options for <em>Cccc</em>
are <em>Ofdm</em> and <em>Dsss</em>. For modulation classes where
optional reduced-bandwidth transmission is possible, this is captured
in the final part of the form above, with <em>b</em> specifying the
nominal signal bandwidth in megahertz. </li>

<li><b>Consolidation of classes support Wi-Fi Information Elements:</b>
When the <em>mesh</em> module was introduced it added a class
hierarchy for modelling of the various Information Elements that were
required. In this release, this class hierarchy has extended by moving
the base classes (WifiInformationElement and
WifiInformationElementVector) into the <em>wifi</em> module. This
change is intended to ease the addition of support for modelling of
further Wi-Fi functionality. </li>

<li><b>Changed for {Ipv4,Ipv6}PacketInfoTag delivery:</b> In order to
deliver ancillary information to the socket interface (fixed in bug 671),
<em>Ipv4PacketInfoTag</em> and <em>Ipv6PacketInfoTag</em> are implemented. 
For the delivery of this information, the following changes are made into 
existing class.

In Ipv4EndPoint class,
<pre>
-  void SetRxCallback (Callback&lt;void,Ptr&lt;Packet&gt;, Ipv4Address, Ipv4Address, uint16_t&gt; callback);
+  void SetRxCallback (Callback&lt;void,Ptr&lt;Packet&gt;, Ipv4Header, uint16_t, Ptr&lt;Ipv4Interface&gt; &gt; callback);

-  void ForwardUp (Ptr&lt;Packet&gt; p, Ipv4Address saddr, Ipv4Address daddr, uint16_t sport);
+  void ForwardUp (Ptr&lt;Packet&gt; p, const Ipv4Header& header, uint16_t sport, 
+                  Ptr&lt;Ipv4Interface&gt; incomingInterface);
</pre>
In Ipv4L4Protocol class,
<pre>
   virtual enum RxStatus Receive(Ptr&lt;Packet&gt; p, 
-                                Ipv4Address const &source,
-                                Ipv4Address const &destination,
+                                Ipv4Header const &header,
                                 Ptr&lt;Ipv4Interface&gt; incomingInterface) = 0;
</pre>
<pre>
-Ipv4RawSocketImpl::ForwardUp (Ptr&lt;const Packet&gt; p, Ipv4Header ipHeader, Ptr&lt;NetDevice&gt; device)
+Ipv4RawSocketImpl::ForwardUp (Ptr&lt;const Packet&gt; p, Ipv4Header ipHeader, Ptr&lt;Ipv4Interface&gt; incomingInterface)

-NscTcpSocketImpl::ForwardUp (Ptr&lt;Packet&gt; packet, Ipv4Address saddr, Ipv4Address daddr, uint16_t port)
+NscTcpSocketImpl::ForwardUp (Ptr&lt;Packet&gt; packet, Ipv4Header header, uint16_t port,
+                             Ptr&lt;Ipv4Interface&gt; incomingInterface)

-TcpSocketImpl::ForwardUp (Ptr&lt;Packet&gt; packet, Ipv4Address saddr, Ipv4Address daddr, uint16_t port)
+TcpSocketImpl::ForwardUp (Ptr&lt;Packet&gt; packet, Ipv4Header header, uint16_t port,
+                          Ptr&lt;Ipv4Interface&gt; incomingInterface)

-UdpSocketImpl::ForwardUp (Ptr&lt;Packet&gt; packet, Ipv4Address saddr, Ipv4Address daddr, uint16_t port)
+UdpSocketImpl::ForwardUp (Ptr&lt;Packet&gt; packet, Ipv4Header header, uint16_t port,
+                          Ptr&lt;Ipv4Interface&gt; incomingInterface)

</pre>
  
</li>
<li>The method OutputStreamWrapper::SetStream (std::ostream *ostream) was removed.</li>
)
</ul>

<h2>Changed behavior:</h2>
<ul>
<li><b>Queue trace behavior during Enqueue changed:</b> The behavior of the
Enqueue trace source has been changed to be more intuitive and to agree with
documentation.  Enqueue and Drop events in src/node/queue.cc are now mutually
exclusive.  In the past, the meaning of an Enqueue event was that the Queue
Enqueue operation was being attempted; and this could be followed by a Drop
event if the Queue was full.  The new behavior is such that a packet is either
Enqueue'd successfully or Drop'ped.

<li><b>Drop trace logged for Ipv4/6 forwarding failure:</b> Fixed bug 861; this 
will add ascii traces (drops) in Ipv4 and Ipv6 traces for forwarding failures

<li><b>Changed default WiFi error rate model for OFDM modulation types:</b> 
Adopted more conservative ErrorRateModel for OFDM modulation types (a/g).
This will require 4 to 5 more dB of received power to get similar results
as before, so users may observe a reduced WiFi range when using the defaults.
See tracker issue 944 for more details.
</ul>

<hr>
<h1>Changes from ns-3.7 to ns-3.8</h1>

<h2>Changes to build system:</h2>

<h2>New API:</h2>

<ul>
<li><b>Matrix propagation loss model:</b> This radio propagation model uses a two-dimensional matrix
of path loss indexed by source and destination nodes.

<li><b>WiMAX net device</b>: The developed WiMAX model attempts to provide an accurate MAC and
PHY level implementation of the 802.16 specification with the Point-to-Multipoint (PMP) mode and the WirelessMAN-OFDM 
PHY layer. By adding WimaxNetDevice objects to ns-3 nodes, one can create models of
802.16-based networks. The source code for the WiMAX models lives in the directory src/devices/wimax.
The model is mainly composed of three layers:
<ul>
<li>The convergence sublayer (CS)
<li>The MAC Common Part Sublayer (MAC-CPS)
<li>The Physical layer
</ul>
The main way that users who write simulation scripts will typically
interact with the Wimax models is through the helper API and through
the publicly visible attributes of the model.
The helper API is defined in src/helper/wimax-helper.{cc,h}.
Three examples containing some code that shows how to setup a 802.16 network are located under examples/wimax/ 

<li><b>MPI Interface for distributed simulation:</b> Enables access
to necessary MPI information such as MPI rank and size.

<li><b>Point-to-point remote channel:</b> Enables point-to-point 
connection between net-devices on different simulators, for use 
with distributed simulation.

<li><b>GetSystemId in simulator:</b> For use with distributed 
simulation, GetSystemId returns zero by non-distributed 
simulators.  For the distributed simulator, it returns the 
MPI rank.

<li><b>Enhancements to src/core/random-variable.cc/h:</b> New Zeta random variable generator. The Zeta random 
distribution is tightly related to the Zipf distribution (already in ns-3.7). See the documentation, 
especially because sometimes the Zeta distribution is called Zipf and viceversa. Here we conform to the 
Wikipedia naming convention, i.e., Zipf is bounded while Zeta isn't. 

<li><b>Two-ray ground propagation loss model:</b> Calculates the crossover distance under which Friis is used. The antenna 
height is set to the nodes z coordinate, but can be added to using the model parameter SetHeightAboveZ, which 
will affect ALL stations

<li><b>Pareto random variable</b> has two new constructors to specify scale and shape:
<pre>
ParetoVariable (std::pair<double, double> params);
ParetoVariable (std::pair<double, double> params, double b);
</pre>
</ul>

<h2>Changes to existing API:</h2>
<ul>
<li><b>Tracing Helpers</b>: The organization of helpers for both pcap and ascii
tracing, in devices and protocols, has been reworked.  Instead of each device 
and protocol helper re-implementing trace enable methods, classes have been 
developed to implement user-level tracing in a consistent way; and device and 
protocol helpers use those classes to provide tracing functionality.<br>
In addition to consistent operation across all helpers, the object name service
has been integrated into the trace file naming scheme.<br>
The internet stack helper has been extensively massaged to make it easier to 
manage traces originating from protocols.  It used to be the case that there 
was essentially no opportunity to filter tracing on interfaces, and resulting
trace file names collided with those created by devices.  File names are now
disambiguated and one can enable traces on a protocol/interface basis analogously
to the node/device granularity of device-based helpers.<br>
The primary user-visible results of this change are that trace-related functions
have been changed from static functions to method calls; and a new object has
been developed to hold streams for ascii traces.<br>
New functionality is present for ascii traces.  It is now possible to create
multiple ascii trace files automatically just as was possible for pcap trace 
files.<br>
The implementation of the helper code has been designed also to provide 
functionality to make it easier for sophisticated users to hook traces of 
various kinds and write results to (file) streams.
Before:
<pre>
  CsmaHelper::EnablePcapAll ();

  std::ofstream ascii;
  ascii.open ("csma-one-subnet.tr", std::ios_base::binary | std::ios_base::out);
  CsmaHelper::EnableAsciiAll (ascii);

  InternetStackHelper::EnableAsciiAll (ascii);
</pre>
After:
<pre>
  CsmaHelper csmaHelper;
  InternetStackHelper stack;
  csmaHelper.EnablePcapAll ();

  AsciiTraceHelper ascii;
  csma.EnableAsciiAll (ascii.CreateFileStream ("csma-one-subnet.tr"));

  stack.EnableAsciiIpv4All (stream);
</pre>


<li><b>Serialization and Deserialization</b> in buffer, nix-vector, 
packet-metadata, and packet has been modified to use raw character 
buffers, rather than the Buffer class
<pre>
+ uint32_t Buffer::GetSerializedSize (void) const;
+ uint32_t Buffer::Serialize (uint8_t* buffer, uint32_t maxSize) const;
+ uint32_t Buffer::Deserialize (uint8_t* buffer, uint32_t size); 

- void NixVector::Serialize (Buffer::Iterator i, uint32_t size) const;
+ uint32_t NixVector::Serialize (uint32_t* buffer, uint32_t maxSize) const;
- uint32_t NixVector::Deserialize (Buffer::Iterator i);
+ uint32_t NixVector::Deserialize (uint32_t* buffer, uint32_t size);

- void PacketMetadata::Serialize (Buffer::Iterator i, uint32_t size) const;
+ uint32_t PacketMetadata::Serialize (uint8_t* buffer, uint32_t maxSize) const;
- uint32_t PacketMetadata::Deserialize (Buffer::Iterator i);
+ uint32_t PacketMetadata::Deserialize (uint8_t* buffer, uint32_t size);

+ uint32_t Packet::GetSerializedSize (void) const;
- Buffer Packet::Serialize (void) const;
+ uint32_t Packet::Serialize (uint8_t* buffer, uint32_t maxSize) const;
- void Packet::Deserialize (Buffer buffer);
+ Packet::Packet (uint8_t const*buffer, uint32_t size, bool magic);
</pre>
<li><b>PacketMetadata uid</b> has been changed to a 64-bit value. The 
lower 32 bits give the uid, while the upper 32-bits give the MPI rank 
for distributed simulations. For non-distributed simulations, the 
upper 32 bits are simply zero.
<pre>
- inline PacketMetadata (uint32_t uid, uint32_t size);
+ inline PacketMetadata (uint64_t uid, uint32_t size);
- uint32_t GetUid (void) const;
+ uint64_t GetUid (void) const;
- PacketMetadata::PacketMetadata (uint32_t uid, uint32_t size);
+ PacketMetadata::PacketMetadata (uint64_t uid, uint32_t size); 

- uint32_t Packet::GetUid (void) const;
+ uint64_t Packet::GetUid (void) const;
</pre>

<li><b>Moved propagation models</b> from src/devices/wifi to src/common

<li><b>Moved Mtu attribute from base class NetDevice</b> This attribute is
now found in all NetDevice subclasses.  
</ul>

<h2>Changed behavior:</h2>
<ul>

</ul>

<hr>
<h1>Changes from ns-3.6 to ns-3.7</h1>


<h2>Changes to build system:</h2>

<h2>New API:</h2>

<ul>
<li><b>Equal-cost multipath for global routing:</b> Enables quagga's
equal cost multipath for Ipv4GlobalRouting, and adds an attribute that
can enable it with random packet distribution policy across equal cost routes.
<li><b>Binding sockets to devices:</b> A method analogous to a SO_BINDTODEVICE
socket option has been introduced to class Socket:  <pre>virtual void Socket::BindToNetDevice (Ptr&lt;NetDevice&gt; netdevice);</pre>
<li><b>Simulator event contexts</b>: The Simulator API now keeps track of a per-event
'context' (a 32bit integer which, by convention identifies a node by its id). Simulator::GetContext
returns the context of the currently-executing event while Simulator::ScheduleWithContext creates an
event with a context different from the execution context of the caller. This API is used
by the ns-3 logging system to report the execution context of each log line.
<li><b>Object::DoStart</b>: Users who need to complete their object setup at the start of a simulation
can override this virtual method, perform their adhoc setup, and then, must chain up to their parent.
<li><b>Ad hoc On-Demand Distance Vector (AODV)</b> routing model, 
<a href=http://www.ietf.org/rfc/rfc3561.txt>RFC 3561</a> </li>
<li><b>Ipv4::IsDestinationAddress (Ipv4Address address, uint32_t iif)</b> Method added to support checks of whether a destination address should be accepted 
as one of the host's own addresses.  RFC 1122 Strong/Weak end system behavior can be changed with a new attribute (WeakEsModel) in class Ipv4.  </li>

<li><b>Net-anim interface</b>: Provides an interface to net-anim, a network animator for point-to-point 
links in ns-3.  The interface generates a custom trace file for use with the NetAnim program.</li>

<li><b>Topology Helpers</b>: New topology helpers have been introduced including PointToPointStarHelper, 
PointToPointDumbbellHelper, PointToPointGridHelper, and CsmaStarHelper.</li>

<li><b>IPv6 extensions support</b>: Provides API to add IPv6 extensions and options. Two examples (fragmentation
and loose routing) are available.</li>
</ul>

<h2>Changes to existing API:</h2>
<ul>
<li><b>Ipv4RoutingProtocol::RouteOutput</b> no longer takes an outgoing 
interface index but instead takes an outgoing device pointer; this affects all
subclasses of Ipv4RoutingProtocol.
<pre>
-  virtual Ptr&lt;Ipv4Route&gt; RouteOutput (Ptr&lt;Packet&gt; p, const Ipv4Header &header, uint32_t oif, Socket::SocketErrno &sockerr) = 0;
+  virtual Ptr&lt;Ipv4Route&gt; RouteOutput (Ptr&lt;Packet&gt; p, const Ipv4Header &header, Ptr&lt;NetDevice&gt; oif, Socket::SocketErrno &sockerr) = 0;
</pre>
<li><b>Ipv6RoutingProtocol::RouteOutput</b> no longer takes an outgoing 
interface index but instead takes an outgoing device pointer; this affects all
subclasses of Ipv6RoutingProtocol.
<pre>
-  virtual Ptr&lt;Ipv6Route&gt; RouteOutput (Ptr&lt;Packet&gt; p, const Ipv6Header &header, uint32_t oif, Socket::SocketErrno &sockerr) = 0;
+  virtual Ptr&lt;Ipv6Route&gt; RouteOutput (Ptr&lt;Packet&gt; p, const Ipv6Header &header, Ptr&lt;NetDevice&gt; oif, Socket::SocketErrno &sockerr) = 0;
</pre>
<li><b>Application::Start</b> and <b>Application::Stop</b> have been renamed to
<b>Application::SetStartTime</b> and <b>Application::SetStopTime</b>.
<li><b>Channel::Send</b>: this method does not really exist but each subclass of the Channel
base class must implement a similar method which sends a packet from a node to another node.
Users must now use Simulator::ScheduleWithContext instead of Simulator::Schedule to schedule
the reception event on a remote node.<br>
For example, before:
<pre>
void
SimpleChannel::Send (Ptr&lt;Packet&gt; p, uint16_t protocol, 
         Mac48Address to, Mac48Address from,
         Ptr&lt;SimpleNetDevice&gt; sender)
{
  for (std::vector&lt;Ptr&lt;SimpleNetDevice&gt; &gt;::const_iterator i = m_devices.begin (); i != m_devices.end (); ++i)
    {
      Ptr&lt;SimpleNetDevice&gt; tmp = *i;
      if (tmp == sender)
  {
    continue;
  }
      Simulator::ScheduleNow (&SimpleNetDevice::Receive, tmp, p->Copy (), protocol, to, from);
    }
}
</pre>
After:
<pre>
void
SimpleChannel::Send (Ptr&lt;Packet&gt; p, uint16_t protocol, 
         Mac48Address to, Mac48Address from,
         Ptr&lt;SimpleNetDevice&gt; sender)
{
  for (std::vector&lt;Ptr&lt;SimpleNetDevice&gt; &gt;::const_iterator i = m_devices.begin (); i != m_devices.end (); ++i)
    {
      Ptr&lt;SimpleNetDevice&gt; tmp = *i;
      if (tmp == sender)
  {
    continue;
  }
      Simulator::ScheduleWithContext (tmp->GetNode ()->GetId (), Seconds (0),
                                      &SimpleNetDevice::Receive, tmp, p->Copy (), protocol, to, from);
    }
}
</pre>

<li><b>Simulator::SetScheduler</b>: this method now takes an ObjectFactory
instead of an object pointer directly. Existing callers can trivially be
updated to use this new method.<br>
Before:
<pre>
Ptr&lt;Scheduler&gt; sched = CreateObject&lt;ListScheduler&gt; ();
Simulator::SetScheduler (sched);
</pre>
After:
<pre>
ObjectFactory sched;
sched.SetTypeId ("ns3::ListScheduler");
Simulator::SetScheduler (sched);
</pre>

<li> Extensions to IPv4 <b>Ping</b> application: verbose output and the ability to configure different ping 
sizes and time intervals (via new attributes)

<li><b>Topology Helpers</b>: Previously, topology helpers such as a point-to-point star existed in the 
PointToPointHelper class in the form of a method (ex: PointToPointHelper::InstallStar).  These topology 
helpers have been pulled out of the specific helper classes and created as separate classes.  Several 
different topology helper classes now exist including PointToPointStarHelper, PointToPointGridHelper, 
PointToPointDumbbellHelper, and CsmaStarHelper.  For example, a user wishes to create a 
point-to-point star network:<br>
Before:
<pre>
NodeContainer hubNode;
NodeContainer spokeNodes;
hubNode.Create (1);
Ptr&lt;Node&gt; hub = hubNode.Get (0);
spokeNodes.Create (nNodes - 1);

PointToPointHelper pointToPoint;
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));
NetDeviceContainer hubDevices, spokeDevices;
pointToPoint.InstallStar (hubNode.Get (0), spokeNodes, hubDevices, spokeDevices);
</pre>
After:
<pre>
PointToPointHelper pointToPoint;
pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("5Mbps"));
pointToPoint.SetChannelAttribute ("Delay", StringValue ("2ms"));
PointToPointStarHelper star (nSpokes, pointToPoint);
</pre>

</li>

</ul>

<h2>Changed behavior:</h2>
<ul>
<li> Changed default value of YansWifiPhy::EnergyDetectionThreshold from
-140.0 dBm to -96.0 dBm.  Changed default value of 
YansWifiPhy::CcaModelThreshold from -140.0 dBm to -99.0 dBm.  Rationale
can be found <a href="http://www.nsnam.org/bugzilla/show_bug.cgi?id=689"> 
here</a>.
</li>
<li> Default TTL of IPv4 broadcast datagrams changed from 1 to 64.</li>
<li> Changed DcfManager::UpdateBackoff (): using flooring instead of rounding in calculation of remaining slots. <a href="http://www.nsnam.org/bugzilla/show_bug.cgi?id=695">
  See bug 695.</a></li>
</ul>


<hr>
<h1>Changes from ns-3.5 to ns-3.6</h1>

<h2>Changes to build system:</h2>
<ul>
<li><b>A new test framework is provided with ns-3.6 that primarilay runs outside waf</b>
<p>"./waf check" now runs the new unit tests of the core part of ns-3.6.  
In order to run the complete test package, use "./test.py" which is 
documented in a new manual -- find it in ./doc/testing.  "./waf check"
no longer generates the introspected Doxygen.  Now use "./waf doxygen"
to do this and generate the Doxygen documentation in one step.
</p>
</ul>

<h2>New API:</h2>
<ul>
<li><b>Longest prefix match, support for metrics, for Ipv4StaticRouting and Ipv6StaticRouting</b>
<p>When performing route lookup, first match for longest prefix, and then
based on metrics (default metric = 0).  If metrics are equal, most recent
addition is picked.  Extends API for support of metrics but preserves
backward compatibility.  One small change is that the default route
is no longer stored as index 0 route in the host route table so 
GetDefaultRoute () must be used.
</p>
</li>
<li><b>Route injection for global routing</b>
<p>Add ability to inject and withdraw routes to Ipv4GlobalRouting.  This
allows a user to insert a route and have it redistributed like an OSPF
external LSA to the rest of the topology.
</p>
</li>

<li><b>Athstats</b>
<p>New classes AthstatsWifiTraceSink and AthstatsHelper.
</p>
</li>
<li><b>WifiRemoteStationManager </b>
<p>New trace sources exported by WifiRemoteStationManager: MacTxRtsFailed, MacTxDataFailed, MacTxFinalRtsFailed and MacTxFinalDataFailed.
</p>
</li>

<li><b> IPv6 additions</b>
<p> Add an IPv6 protocol and ICMPv6 capability.
<ul>
<li> new classes Ipv6, Ipv6Interface, Ipv6L3Protocol, Ipv6L4Protocol
<li> Ipv6RawSocket (no UDP or TCP capability yet)
<li> a set of classes to implement Icmpv6, including neighbor discovery,
router solicitation, DAD
<li> new applications Ping6 and Radvd
<li> routing objects Ipv6Route and Ipv6MulticastRoute
<li> routing protocols Ipv6ListRouting and Ipv6StaticRouting
<li> examples: icmpv6-redirect.cc, ping6.cc, radvd.cc, radvd-two-prefix.cc, simple-routing-ping6.cc
</ul>
</p>
</li> 

<li><b>Wireless Mesh Networking models</b>
<ul>
<p>
<li> General multi-interface mesh stack infrastructure (devices/mesh module).
<li> IEEE 802.11s (Draft 3.0) model including Peering Management Protocol and HWMP.
<li> Forwarding Layer for Meshing (FLAME) protocol.
</ul>
</p>
</li>

<li><b>802.11 enhancements</b>
<p>
<ul>
<li> 10MHz and 5MHz channel width supported by 802.11a model (Ramon Bauza and Kirill Andreev).
</ul>
<ul>
<li> Channel switching support. YansWifiPhy can now switch among different channels (Ramon Bauza and Pavel Boyko).
</ul>
</p>
</li>

<li><b> Nix-vector Routing</b>
<p> Add nix-vector routing protocol
<ul>
<li> new helper class Ipv4NixVectorHelper
</ul>
<ul>
<li> examples: nix-simple.cc, nms-p2p-nix.cc
</ul> 
</p>
</li>

<li><b>New Test Framework</b>
<p> Add TestCase, TestSuite classes
<ul>
<li> examples: src/core/names-test-suite.cc, src/core/random-number-test-suite.cc, src/test/ns3tcp/ns3tcp-cwnd-test-suite.cc
</ul> 
</p>
</li>

</ul>

<h2>Changes to existing API:</h2>
<ul>
<li><b>InterferenceHelper</b>
<p>The method InterferenceHelper::CalculateTxDuration (uint32_t size, WifiMode payloadMode, WifiPreamble preamble) has been made static, so that the frame duration depends only on the characteristics of the frame (i.e., the function parameters) and not on the particular standard which is used by the receiving PHY. This makes it now possible to correctly calculate the duration of incoming frames in scenarios in which devices using different PHY configurations coexist in the same channel (e.g., a BSS using short preamble and another BSS using long preamble). </p>
<p> The following member methods have been added to InterferenceHelper:</p>
<pre>
  static WifiMode GetPlcpHeaderMode (WifiMode, WifiPreamble);
  static uint32_t GetPlcpHeaderDurationMicroSeconds (WifiMode, WifiPreamble);
  static uint32_t GetPlcpPreambleDurationMicroSeconds (WifiMode, WifiPreamble);
  static uint32_t GetPayloadDurationMicroSeconds (size, WifiMode); </pre>
<p> The following member methods have been removed from InterferenceHelper:</p>
<pre>
  void Configure80211aParameters (void);
  void Configure80211bParameters (void);
  void Configure80211_10MhzParameters (void);
  void Configure80211_5MhzParameters (void);</pre>
</li>
<li><b>WifiMode</b>
<p>WifiMode now has a WifiPhyStandard attribute which identifies the standard the WifiMode belongs to. To properly set this attribute when creating a new WifiMode, it is now required to explicitly pass a WifiPhyStandard parameter to all WifiModeFactory::CreateXXXX() methods. The WifiPhyStandard value of an existing WifiMode can be retrieved using the new method WifiMode::GetStandard().</p>
</li>
<li><b>NetDevice</b>
<p>In order to have multiple link change callback in NetDevice (i.e. to flush ARP and IPv6 neighbor discovery caches), the following member method has been renamed:</p>
<pre>
- virtual void SetLinkChangeCallback (Callback&lt;void&gt; callback);
+ virtual void AddLinkChangeCallback (Callback&lt;void&gt; callback);</pre>
Now each NetDevice subclasses have a TracedCallback&lt;&gt; object (list of callbacks) instead of Callback&lt;void&gt; ones.
</li>
</ul>

<hr>
<h1>Changes from ns-3.4 to ns-3.5</h1>

<h2>Changes to build system:</h2>
<ul>
</ul>

<h2>New API:</h2>

<ul>
<li><b>YansWifiPhyHelper supporting radiotap and prism PCAP output</b>
<p>The newly supported pcap formats can be adopted by calling the following new method of YansWifiPhyHelper:</p>
<pre>
 +  void SetPcapFormat (enum PcapFormat format);
</pre>
where format is one of PCAP_FORMAT_80211_RADIOTAP, PCAP_FORMAT_80211_PRISM or  PCAP_FORMAT_80211. By default, PCAP_FORMAT_80211 is used, so the default PCAP format is the same as before.</p>
</li>

<li> <b>attributes for class Ipv4</b>
<p> class Ipv4 now contains attributes in ipv4.cc; the first one
is called "IpForward" that will enable/disable Ipv4 forwarding.  
</li>

<li> <b>packet tags</b>
<p>class Packet now contains AddPacketTag, RemovePacketTag and PeekPacketTag 
which can be used to attach a tag to a packet, as opposed to the old 
AddTag method which attached a tag to a set of bytes. The main 
semantic difference is in how these tags behave in the presence of 
fragmentation and reassembly.
</li>

</ul>

<h2>Changes to existing API:</h2>
<ul>

<li><b>Ipv4Interface::GetMtu () deleted</b>
  <p>The Ipv4Interface API is private to internet-stack module; this method
was just a pass-through to GetDevice ()-&gt;GetMtu ().
  </p>
</li>

<li><b>GlobalRouteManager::PopulateRoutingTables () and RecomputeRoutingTables () are deprecated </b>
  <p>This API has been moved to the helper API and the above functions will
be removed in ns-3.6.  The new API is:
<pre>
Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
Ipv4GlobalRoutingHelper::RecomputeRoutingTables ();
</pre>
Additionally, these low-level functions in GlobalRouteManager are now public,
allowing more API flexibility at the low level ns-3 API:
<pre>
GlobalRouteManager::DeleteGlobalRoutes ();
GlobalRouteManager::BuildGlobalRoutingDatabase ();
GlobalRouteManager::InitializeRoutes ();
</pre>
  </p>
</li>

<li><b>CalcChecksum attribute changes</b>
  <p>Four IPv4 CalcChecksum attributes (which enable the computation of 
checksums that are disabled by default) have been collapsed into one global 
value in class Node.  These four calls: 
<pre>
Config::SetDefault ("ns3::Ipv4L3Protocol::CalcChecksum", BooleanValue (true)); 
Config::SetDefault ("ns3::Icmpv4L4Protocol::CalcChecksum", BooleanValue (true));
Config::SetDefault ("ns3::TcpL4Protocol::CalcChecksum", BooleanValue (true));
Config::SetDefault ("ns3::UdpL4Protocol::CalcChecksum", BooleanValue (true));
</pre>
are replaced by one call to:
<pre>
GlobalValue::Bind ("ChecksumEnabled", BooleanValue (true));
</pre>
  </p>
</li>

<li><b>CreateObject changes</b>
  <p>CreateObject is now able to construct objects with a non-default constructor.
   If you used to pass attribute lists to CreateObject, you must now use CreateObjectWithAttributes.
  </p>
</li>

<li> <b>packet byte tags renaming</b>
  <ul>
  <li>Packet::AddTag to Packet::AddByteTag</li>
  <li>Packet::FindFirstMatchingTag to Packet::FindFirstMatchingByteTag</li>
  <li>Packet::RemoveAllTags to Packet::RemoveAllByteTags</li>
  <li>Packet::PrintTags to Packet::PrintByteTags</li>
  <li>Packet::GetTagIterator to Packet::GetByteTagIterator</li>
  </ul>
</li>

<li><b>YansWifiPhyHelper::EnablePcap* methods not static any more</b>
<p>To accommodate the possibility of configuring the PCAP format used for wifi promiscuous mode traces, several methods of YansWifiPhyHelper had to be made non-static:
<pre>
-  static void EnablePcap (std::string filename, uint32_t nodeid, uint32_t deviceid);
+         void EnablePcap (std::string filename, uint32_t nodeid, uint32_t deviceid);
-  static void EnablePcap (std::string filename, Ptr&lt;NetDevice&gt; nd);
+         void EnablePcap (std::string filename, Ptr&lt;NetDevice&gt; nd);
-  static void EnablePcap (std::string filename, std::string ndName);
+         void EnablePcap (std::string filename, std::string ndName);
-  static void EnablePcap (std::string filename, NetDeviceContainer d);
+         void EnablePcap (std::string filename, NetDeviceContainer d);
-  static void EnablePcap (std::string filename, NodeContainer n);
+         void EnablePcap (std::string filename, NodeContainer n);
-  static void EnablePcapAll (std::string filename);
+         void EnablePcapAll (std::string filename);
</pre>
</p>
</li>

<li><b>Wifi Promisc Sniff interface modified </b>
<p> 
To accommodate support for the radiotap and prism headers in PCAP traces, the interface for promiscuos mode sniff in the wifi device was changed. The new implementation was heavily inspired by the way the madwifi driver handles monitor mode. A distinction between TX and RX events is introduced, to account for the fact that different information is to be put in the radiotap/prism header (e.g., RSSI and noise make sense only for RX packets). The following are the relevant modifications to the WifiPhy class:
<pre>
-  void NotifyPromiscSniff (Ptr&lt;const Packet&gt; packet);
+  void NotifyPromiscSniffRx (Ptr&lt;const Packet&gt; packet, uint16_t channelFreqMhz, uint32_t rate, bool isShortPreamble, double signalDbm, double noiseDbm);
+  void NotifyPromiscSniffTx (Ptr&lt;const Packet&gt; packet, uint16_t channelFreqMhz, uint32_t rate, bool isShortPreamble);
-  TracedCallback&lt;Ptr&lt;const Packet&gt; &gt; m_phyPromiscSnifferTrace;
+  TracedCallback&lt;Ptr&lt;const Packet&gt;, uint16_t, uint32_t, bool, double, double&gt; m_phyPromiscSniffRxTrace;
+  TracedCallback&lt;Ptr&lt;const Packet&gt;, uint16_t, uint32_t, bool&gt; m_phyPromiscSniffTxTrace;
</pre>
The above mentioned callbacks are expected to be used to call the following method to write Wifi PCAP traces in promiscuous mode:
<pre>
+  void WriteWifiMonitorPacket(Ptr&lt;const Packet&gt; packet, uint16_t channelFreqMhz, uint32_t rate, bool isShortPreamble, bool isTx, double signalDbm, double noiseDbm);
</pre>
In the above method, the isTx parameter is to be used to differentiate between TX and RX packets. For an example of how to implement these callbacks, see the implementation of PcapSniffTxEvent and PcapSniffRxEvent in src/helper/yans-wifi-helper.cc
</p>
</li>

<li><b> Routing decoupled from class Ipv4</b>
<p> All calls of the form "Ipv4::AddHostRouteTo ()" etc. (i.e. to 
add static routes, both unicast and multicast) have been moved to a new 
class Ipv4StaticRouting.  In addition, class Ipv4 now holds only
one possible routing protocol; the previous way to add routing protocols
(by ordered list of priority) has been moved to a new class Ipv4ListRouting.
Class Ipv4 has a new minimal routing API (just to set and get the routing
protocol):
<pre>
-  virtual void AddRoutingProtocol (Ptr&lt;Ipv4RoutingProtocol&gt; routingProtocol, int16_t priority) = 0;
+  virtual void SetRoutingProtocol (Ptr&lt;Ipv4RoutingProtocol&gt; routingProtocol) = 0;
+  virtual Ptr&lt;Ipv4RoutingProtocol&gt; GetRoutingProtocol (void) const = 0;
</pre>
</li>

<li><b> class Ipv4RoutingProtocol is refactored</b>
<p> The abstract base class Ipv4RoutingProtocol has been refactored to
align with corresponding Linux Ipv4 routing architecture, and has been
moved from ipv4.h to a new file ipv4-routing-protocol.h.  The new
methods (RouteOutput () and RouteInput ()) are aligned with Linux 
ip_route_output() and ip_route_input().  However,
the general nature of these calls (synchronous routing lookup for
locally originated packets, and an asynchronous, callback-based lookup
for forwarded packets) is still the same.
<pre>
-  typedef Callback&lt;void, bool, const Ipv4Route&amp;, Ptr&lt;Packet&gt;, const Ipv4Header&amp;&gt; RouteReplyCallback;
+  typedef Callback&lt;void, Ptr&lt;Ipv4Route&gt;, Ptr&lt;const Packet&gt;, const Ipv4Header &amp;&gt; UnicastForwardCallback;
+  typedef Callback&lt;void, Ptr&lt;Ipv4MulticastRoute&gt;, Ptr&lt;const Packet&gt;, const Ipv4Header &amp;&gt; MulticastForwardCallback;
+  typedef Callback&lt;void, Ptr&lt;const Packet&gt;, const Ipv4Header &amp;, uint32_t &gt; LocalDeliverCallback;
+  typedef Callback&lt;void, Ptr&lt;const Packet&gt;, const Ipv4Header &amp;&gt; ErrorCallback;
-  virtual bool RequestInterface (Ipv4Address destination, uint32_t&amp; interface) = 0;
+  virtual Ptr&lt;Ipv4Route&gt; RouteOutput (Ptr&lt;Packet&gt; p, const Ipv4Header &amp;header, uint32_t oif, Socket::SocketErrno &amp;errno) = 0;
-  virtual bool RequestRoute (uint32_t interface,
-                            const Ipv4Header &amp;ipHeader,
-                            Ptr&lt;Packet&gt; packet,
-                            RouteReplyCallback routeReply) = 0;
+  virtual bool RouteInput  (Ptr&lt;const Packet&gt; p, const Ipv4Header &amp;header, Ptr&lt;const NetDevice&gt; idev,
+                             UnicastForwardCallback ucb, MulticastForwardCallback mcb,
+                             LocalDeliverCallback lcb, ErrorCallback ecb) = 0;
</pre>

</li>
<li><b> previous class Ipv4Route, Ipv4MulticastRoute renamed; new classes with
those same names added</b>
<p> The previous class Ipv4Route and Ipv4MulticastRoute are used by 
Ipv4StaticRouting and Ipv4GlobalRouting to record internal routing table
entries, so they were renamed to class Ipv4RoutingTableEntry and
Ipv4MulticastRoutingTableEntry, respectively.  In their place, new
class Ipv4Route and class Ipv4MulticastRoute have been added.  These
are reference-counted objects that are analogous to Linux struct
rtable and struct mfc_cache, respectively, to achieve better compatibility
with Linux routing architecture in the future.  

<li><b> class Ipv4 address-to-interface mapping functions changed</b>
<p>  There was some general cleanup of functions that involve mappings
from Ipv4Address to either NetDevice or Ipv4 interface index.  
<pre>
-  virtual uint32_t FindInterfaceForAddr (Ipv4Address addr) const = 0;
-  virtual uint32_t FindInterfaceForAddr (Ipv4Address addr, Ipv4Mask mask) const = 0;
+  virtual int32_t GetInterfaceForAddress (Ipv4Address address) const = 0;
+  virtual int32_t GetInterfaceForPrefix (Ipv4Address address, Ipv4Mask mask) const = 0;
-  virtual int32_t FindInterfaceForDevice(Ptr&lt;NetDevice&gt; nd) const = 0;
+  virtual int32_t GetInterfaceForDevice (Ptr&lt;const NetDevice&gt; device) const = 0;
-  virtual Ipv4Address GetSourceAddress (Ipv4Address destination) const = 0;
-  virtual bool GetInterfaceForDestination (Ipv4Address dest,
-  virtual uint32_t GetInterfaceByAddress (Ipv4Address addr, Ipv4Mask mask = Ipv4Mask("255.255.255.255"));
</pre>

<li><b> class Ipv4 multicast join API deleted</b>
<p> The following methods are not really used in present form since IGMP
is not being generated, so they have been removed (planned to be replaced
by multicast socket-based calls in the future):

<pre>
- virtual void JoinMulticastGroup (Ipv4Address origin, Ipv4Address group) = 0;
- virtual void LeaveMulticastGroup (Ipv4Address origin, Ipv4Address group) = 0;
</pre>


<li><b>Deconflict NetDevice::ifIndex and Ipv4::ifIndex (bug 85).</b>
<p>All function parameters named "ifIndex" that refer 
to an Ipv4 interface are instead named "interface".
<pre>
- static const uint32_t Ipv4RoutingProtocol::IF_INDEX_ANY = 0xffffffff;
+ static const uint32_t Ipv4RoutingProtocol::INTERFACE_ANY = 0xffffffff;

- bool Ipv4RoutingProtocol::RequestIfIndex (Ipv4Address destination, uint32_t&amp; ifIndex);
+ bool Ipv4RoutingProtocol::RequestInterface (Ipv4Address destination, uint32_t&amp; interface);
(N.B. this particular function is planned to be renamed to RouteOutput() in the
proposed IPv4 routing refactoring)

- uint32_t Ipv4::GetIfIndexByAddress (Ipv4Address addr, Ipv4Mask mask);
+ int_32t Ipv4::GetInterfaceForAddress (Ipv4Address address, Ipv4Mask mask) const;

- bool Ipv4::GetIfIndexForDestination (Ipv4Address dest, uint32_t &amp;ifIndex) const;
+ bool Ipv4::GetInterfaceForDestination (Ipv4Address dest, uint32_t &amp;interface) const;
(N.B. this function is not needed in the proposed Ipv4 routing refactoring)
</pre>


<li><b>Allow multiple IPv4 addresses to be assigned to an interface (bug 188)</b>
  <ul>
  <li> Add class Ipv4InterfaceAddress:  
  This is a new class to resemble Linux's struct in_ifaddr.  It holds IP addressing information, including mask,
  broadcast address, scope, whether primary or secondary, etc.
  <pre>
+  virtual uint32_t AddAddress (uint32_t interface, Ipv4InterfaceAddress address) = 0;
+  virtual Ipv4InterfaceAddress GetAddress (uint32_t interface, uint32_t addressIndex) const = 0;
+  virtual uint32_t GetNAddresses (uint32_t interface) const = 0;
  </pre>
  <li>Regarding legacy API usage, typically where you once did the following,
  using the public Ipv4 class interface (e.g.):
  <pre>
  ipv4A-&gt;SetAddress (ifIndexA, Ipv4Address ("172.16.1.1"));
  ipv4A-&gt;SetNetworkMask (ifIndexA, Ipv4Mask ("255.255.255.255"));
  </pre>
  you now do:
  <pre>
  Ipv4InterfaceAddress ipv4IfAddrA = Ipv4InterfaceAddress (Ipv4Address ("172.16.1.1"), Ipv4Mask ("255.255.255.255"));
  ipv4A-&gt;AddAddress (ifIndexA, ipv4IfAddrA);
  </pre>
  <li> At the helper API level, one often gets an address from an interface
  container.  We preserve the legacy GetAddress (uint32_t i) but it
  is documented that this will return only the first (address index 0)
  address on the interface, if there are multiple such addresses. 
  We provide also an overloaded variant for the multi-address case: 

  <pre>
Ipv4Address Ipv4InterfaceContainer::GetAddress (uint32_t i)
+ Ipv4Address Ipv4InterfaceContainer::GetAddress (uint32_t i, uint32_t j)
  </pre>

  </ul>

<li><b>New WifiMacHelper objects</b>
<p>The type of wifi MAC is now set by two new specific helpers, NqosWifiMacHelper for non QoS MACs and QosWifiMacHelper for Qos MACs. They are passed as argument to WifiHelper::Install methods.</li>
  <pre>
- void WifiHelper::SetMac (std::string type, std::string n0 = "", const AttributeValue &amp;v0 = EmptyAttributeValue (),...)

- NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &amp;phyHelper, NodeContainer c) const
+ NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &amp;phyHelper, const WifiMacHelper &amp;macHelper, NodeContainer c) const

- NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &amp;phy, Ptr&lt;Node&gt; node) const
+ NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &amp;phy, const WifiMacHelper &amp;mac, Ptr&lt;Node&gt; node) const

- NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &amp;phy, std::string nodeName) const
+ NetDeviceContainer WifiHelper::Install (const WifiPhyHelper &amp;phy, const WifiMacHelper &amp;mac, std::string nodeName) const
  </pre>
  See src/helper/nqos-wifi-mac-helper.h and src/helper/qos-wifi-mac-helper.h for more details.
  </p>

<li><b>Remove Mac48Address::IsMulticast</b>
  <p>This method was considered buggy and unsafe to call. Its replacement is Mac48Address::IsGroup.
  </li>

</ul>

<h2>Changed behavior:</h2>
<ul>
</ul>

<hr>
<h1>Changes from ns-3.3 to ns-3.4</h1>

<h2>Changes to build system:</h2>
<ul>
<li>A major option regarding the downloading and building of ns-3 has been
added for ns-3.4 -- the ns-3-allinone feature.  This allows a user to
get the most common options for ns-3 downloaded and built with a minimum
amount of trouble.  See the ns-3 tutorial for a detailed explanation of
how to use this new feature.</li>

<li>The build system now runs build items in parallel by default.  This includes
the regression tests.</li>
</ul>

<h2>New API:</h2>
<ul>
<li>XML support has been added to the ConfigStore in src/contrib/config-store.cc</li>

<li>The ns-2 calendar queue scheduler option has been ported to src/simulator</li>

<li>A ThreeLogDistancePropagationLossModel has been added to src/devices/wifi</li>

<li>ConstantAccelerationMobilityModel in src/mobility/constant-acceleration-mobility-model.h</li>

<li>A new emulation mode is supported with the TapBridge net device (see
src/devices/tap-bridge)</li>

<li>A new facility for naming ns-3 Objects is included (see
src/core/names.{cc,h})</li>

<li>Wifi multicast support has been added in src/devices/wifi</li>
</ul>

<h2>Changes to existing API:</h2>

<ul>
<li>Some fairly significant changes have been made to the API of the
random variable code.  Please see the ns-3 manual and src/core/random-variable.cc
for details.</li>

<li>The trace sources in the various NetDevice classes has been completely
reworked to allow for a consistent set of trace sources across the
devices.  The names of the trace sources have been changed to provide
some context with respect to the level at which the trace occurred.
A new set of trace sources has been added which emulates the behavior
of packet sniffers.  These sources have been used to implement tcpdump-
like functionality and are plumbed up into the helper classes.  The 
user-visible changes are the trace source name changes and the ability
to do promiscuous-mode pcap tracing via helpers.  For further information
regarding these changes, please see the ns-3 manual</li>

<li>StaticMobilityModel has been renamed ConstantPositionMobilityModel
StaticSpeedMobilityModel has been renamed ConstantVelocityMobilityModel</li>

<li>The Callback templates have been extended to support more parameters.
See src/core/callback.h</li>

<li>Many helper API have been changed to allow passing Object-based parameters
as string names to ease working with the object name service.</li>

<li>The Config APIs now accept path segments that are names defined by the
object name service.</li>

<li>Minor changes were made to make the system build under the Intel C++ compiler.</li>

<li>Trace hooks for association and deassociation to/from an access point were
added to src/devices/wifi/nqsta-wifi-mac.cc</li>
</ul>

<h2>Changed behavior:</h2>

<ul>
<li>The tracing system rework has introduced some significant changes in the
behavior of some trace sources, specifically in the positioning of trace sources
in the device code.  For example, there were cases where the packet transmit 
trace source was hit before the packet was enqueued on the device transmit quueue.
This now happens just before the packet is transmitted over the channel medium.
The scope of the changes is too large to be included here.  If you have concerns
regarding trace semantics, please consult the net device documentation for details.
As is usual, the ultimate source for documentation is the net device source code.</li>
</ul>

<hr>
<h1>Changes from ns-3.2 to ns-3.3</h1>

<h2>New API:</h2>
<ul>
<li>
ns-3 ABORT macros in src/core/abort.h
Config::MatchContainer
ConstCast and DynamicCast helper functions for Ptr casting
StarTopology added to several topology helpers
NetDevice::IsBridge () 
</li>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/4c1c3f6bcd03">4c1c3f6bcd03</a></li>
<ul>
<li>
The PppHeader previously defined in the point-to-point-net-device code has been 
made public.
</li>
</ul>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/16c2970a0344">16c2970a0344</a></li>
<ul>
<li>
An emulated net device has been added as enabling technology for ns-3 emulation
scenarios.  See src/devices/emu and examples/emu-udp-echo.cc for details.
</li>
</ul>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/4222173d1e6d">4222173d1e6d</a></li>
<ul>
<li>
Added method InternetStackHelper::EnableAsciiChange to allow allow a user to 
hook ascii trace to the drop trace events in Ipv4L3Protocol and ArpL3Protocol.
</li>
</ul>

</ul>
<h2>Changes to existing API:</h2>
<ul>

<li> NetDevice::MakeMulticastAddress() was renamed to NetDevice::GetMulticast()
and the original GetMulticast() removed </li>

<li> Socket API changes:
<ul>
<li> return type of SetDataSentCallback () changed from bool to void </li>
<li> Socket::Listen() no longer takes a queueLimit argument</li>
</ul>

<li> As part of the Wifi Phy rework, there have been several API changes
at the low level and helper API level.  </li>
<ul>
<li>  At the helper API level, the WifiHelper was split to three classes: 
a WifiHelper, a YansWifiChannel helper, and a YansWifiPhy helper.  Some
functions like Ascii and Pcap tracing functions were moved from class
WifiHelper to class YansWifiPhyHelper. 
<li>  At the low-level API, there have been a number of changes to
make the Phy more modular:</li>
<ul>
<li> composite-propagation-loss-model.h is removed</li>
<li> DcfManager::NotifyCcaBusyStartNow() has changed name</li>
<li> fragmentation related functions (e.g. DcaTxop::GetNFragments()) have
changed API to account for some implementation changes</li>
<li> Interference helper and error rate model added </li>
<li> JakesPropagationLossModel::GetLoss() moved to PropagationLoss() class</li>
<li> base class WifiChannel made abstract </li>
<li> WifiNetDevice::SetChannel() removed </li>
<li> a WifiPhyState helper class added </li>
<li> addition of the YansWifiChannel and YansWifiPhy classes </li>
</ul>
</ul>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/dacfd1f07538">dacfd1f07538</a></li>
<ul>
<li>
Change attribute "RxErrorModel" to "ReceiveErrorModel" in CsmaNetDevice for 
consistency between devices.
</li>
</ul>

</ul>
<h2>changed behavior:</h2>
<ul>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/ed0dfce40459">ed0dfce40459</a></li>
<ul>
<li>
Relax reasonableness testing in Ipv4AddressHelper::SetBase to allow the 
assignment of /32 addresses.
</li>
</ul>

<li>17-11-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/756887a9bbea">756887a9bbea</a></li>
<ul>
<li>
Global routing supports bridge devices.
</li>
</ul>
</ul>

<hr>
<h1>Changes from ns-3.1 to ns-3.2</h1>

<h2>New API:</h2>
<ul>

<li>26-08-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/5aa65b1ea001">5aa65b1ea001</a></li>
<ul>
<li>
Add multithreaded and real-time simulator implementation.  Allows for emulated
net devices running in threads other than the main simulation thread to schedule
events.  Allows for pacing the simulation clock at 1x real-time.
</li>
</ul>


<li>26-08-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/c69779f5e51e">c69779f5e51e</a></li>
<ul>
<li>
Add threading and synchronization primitives.  Enabling technology for 
multithreaded simulator implementation.
</li>
</ul>

</ul>
<h2>New API in existing classes:</h2>
<ul>

<li>01-08-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/a18520551cdf">a18520551cdf</a></li>
<ul>
<li>class ArpCache has two new attributes:  MaxRetries 
and a Drop trace.  It also has some new public methods but these are 
mostly for internal use.
</ul>
</li>

</ul>
<h2>Changes to existing API:</h2>
<ul>

<li>05-09-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/aa1fb0f43571">aa1fb0f43571</a></li>
<ul>
<li>
Change naming of MTU and packet size attributes in CSMA and Point-to-Point devices<br>
After much discussion it was decided that the preferred way to think about 
the different senses of transmission units and encapsulations was to call the 
MAC MTU simply MTU and to use the overall packet size as the PHY-level attribute
of interest.  See the Doxygen of CsmaNetDevice::SetFrameSize and 
PointToPointNetDevice::SetFrameSize for a detailed description.
</li>
</ul>

<li>25-08-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/e5ab96db540e">e5ab96db540e</a></li>
<ul>
<li>
bug 273: constify packet pointers.<br>
The normal and the promiscuous receive callbacks of the NetDevice API
have been changed from:
<pre>
Callback&lt;bool,Ptr&lt;NetDevice&gt;,Ptr&lt;Packet&gt;,uint16_t,const Address &amp;&gt;
Callback&lt;bool,Ptr&lt;NetDevice&gt;, Ptr&lt;Packet&gt;, uint16_t,
         const Address &amp;, const Address &amp;, enum PacketType &gt;
</pre>
to:
<pre>
Callback&lt;bool,Ptr&lt;NetDevice&gt;,Ptr&lt;const Packet&gt;,uint16_t,const Address &amp;&gt;
Callback&lt;bool,Ptr&lt;NetDevice&gt;, Ptr&lt;const Packet&gt;, uint16_t,
         const Address &amp;, const Address &amp;, enum PacketType &gt;
</pre>
to avoid the kind of bugs reported in 
<a href="http://www.nsnam.org/bugzilla/show_bug.cgi?id=273">bug 273</a>.
Users who implement a subclass of the NetDevice base class need to change the signature
of their SetReceiveCallback and SetPromiscReceiveCallback methods.
</li>
</ul>


<li>04-08-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/cba7b2b80fe8">cba7b2b80fe8</a></li>
<ul>
<li>
Cleanup of MTU confusion and initialization in CsmaNetDevice<br>
The MTU of the CsmaNetDevice defaulted to 65535.  This did not correspond with
the expected MTU found in Ethernet-like devices.  Also there was not clear 
documentation regarding which MTU was being set.  There are two MTU here, one
at the MAC level and one at the PHY level.  We split out the MTU setting to make
this more clear and set the default PHY level MTU to 1500 to be more like
Ethernet.  The encapsulation mode defaults to LLC/SNAP which then puts the
MAC level MTU at 1492 by default.  We allow users to now set the encapsulation
mode, MAC MTU and PHY MTU while keeping the three values consistent.  See the
Doxygen of CsmaNetDevice::SetMaxPayloadLength for a detailed description of the
issues and solution.
</li>
</ul>

<li>21-07-2008; changeset 
<a href="
http://code.nsnam.org/ns-3-dev/rev/99698bc858e8">99698bc858e8</a></li>
<ul>
<li> class NetDevice has added a pure virtual method that
must be implemented by all subclasses:
<pre>
virtual void SetPromiscReceiveCallback (PromiscReceiveCallback cb) = 0;
</pre>
All NetDevices must support this method, and must call this callback
when processing packets in the receive direction (the appropriate place
to call this is device-dependent).  An approach to stub this out
temporarily, if you do not care about immediately enabling this
functionality, would be to add this to your device:
<pre>
void
ExampleNetDevice::SetPromiscReceiveCallback
(NetDevice::PromiscReceiveCallback cb)
{ 
  NS_ASSERT_MSG (false, "No implementation yet for
SetPromiscReceiveCallback");
}
</pre>
To implement this properly, consult the CsmaNetDevice for examples of
when the m_promiscRxCallback is called.
</li>
</ul>

<li>03-07-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/d5f8e5fae1c6">d5f8e5fae1c6</a></li>
<ul>
<li>
Miscellaneous cleanup of Udp Helper API, to fix bug 234
<pre>
class UdpEchoServerHelper
{
public:
- UdpEchoServerHelper ();
- void SetPort (uint16_t port); 
+ UdpEchoServerHelper (uint16_t port);
+ 
+ void SetAttribute (std::string name, const AttributeValue &amp;value);
ApplicationContainer Install (NodeContainer c);

class UdpEchoClientHelper
{
public:
- UdpEchoClientHelper ();
+ UdpEchoClientHelper (Ipv4Address ip, uint16_t port);
- void SetRemote (Ipv4Address ip, uint16_t port);
- void SetAppAttribute (std::string name, const AttributeValue &amp;value);
+ void SetAttribute (std::string name, const AttributeValue &amp;value);
ApplicationContainer Install (NodeContainer c);
</pre>
</li>
</ul>

<li>03-07-2008; changeset 
<a href="
http://code.nsnam.org/ns-3-dev/rev/3cdd9d60f7c7">3cdd9d60f7c7</a></li>
<ul>
<li>
Rename all instances method names using "Set..Parameter" to "Set..Attribute"
(bug 232)
</li>
<li> How to fix your code:  Any use of helper API that was using a method
"Set...Parameter()" should be changed to read "Set...Attribute()".  e.g.
<pre>
- csma.SetChannelParameter ("DataRate", DataRateValue (5000000));
- csma.SetChannelParameter ("Delay", TimeValue (MilliSeconds (2)));
+ csma.SetChannelAttribute ("DataRate", DataRateValue (5000000));
+ csma.SetChannelAttribute ("Delay", TimeValue (MilliSeconds (2)));
</pre>
</li>
</ul>
</li>

</ul>
<h2>Changed behavior:</h2>
<ul>

<li>07-09-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/5d836ab1523b">5d836ab1523b</a></li>
<ul>

<li>
Implement a finite receive buffer for TCP<br>
The native TCP model in TcpSocketImpl did not support a finite receive buffer.
This changeset adds the following functionality in this regard:
<ul>
<li>
Being able to set the receiver buffer size through the attributes system.
</li>
<li>
This receiver buffer size is now correctly exported in the TCP header as the
advertised window.  Prior to this changeset, the TCP header advertised window
was set to the maximum size of 2^16 bytes.
window
</li>
<li>
The aforementioned window size is correctly used for flow control, i.e. the
sending TCP will not send more data than available space in the receiver's
buffer.
</li>
<li>
In the case of a receiver window collapse, when a advertised zero-window
packet is received, the sender enters the persist probing state in which
it sends probe packets with one payload byte at exponentially backed-off
intervals up to 60s.  The receiver will continue to send advertised 
zero-window ACKs of the old data so long as the receiver buffer remains full.
When the receiver window clears up due to an application read, the TCP
will finally ACK the probe byte, and update its advertised window appropriately.
</li>
</ul>
See 
<a href="http://www.nsnam.org/bugzilla/show_bug.cgi?id=239"> bug 239 </a> for
more.
</li>
</ul>

<li>07-09-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/7afa66c2b291">7afa66c2b291</a></li>
<ul>
<li>
Add correct FIN exchange behavior during TCP closedown<br>
The behavior of the native TcpSocketImpl TCP model was such that the final
FIN exchange was not correct, i.e. calling Socket::Close didn't send a FIN
packet, and even if it had, the ACK never came back, and even if it had, the
ACK would have incorrect sequence number.  All these various problems have been
addressed by this changeset.  See 
<a href="http://www.nsnam.org/bugzilla/show_bug.cgi?id=242"> bug 242 </a> for
more.
</li>
</ul>

<li> 28-07-2008; changeset 
<a href="http://code.nsnam.org/ns-3-dev/rev/6f68f1044df1">6f68f1044df1</a>
<ul>
<li>
OLSR: HELLO messages hold time changed to 3*hello
interval from hello interval.  This is an important bug fix as
hold time == refresh time was never intentional, as it leads to
instability in neighbor detection.
</ul>
</li>

</ul>

</body>
</html>
